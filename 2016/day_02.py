# %% [markdown]
# ## --- Day 2: Bathroom Security ---
#
# You arrive at **Easter Bunny Headquarters** under cover of darkness. However,
# you left in such a rush that you forgot to use the bathroom! Fancy office
# buildings like this one usually have keypad locks on their bathrooms, so you
# search the front desk for the code.
#
# "In order to improve security," the document you find says, "bathroom codes
# will no longer be written down. Instead, please memorize and follow the
# procedure below to access the bathrooms."
#
# The document goes on to explain that each button to be pressed can be found by
# starting on the previous button and moving to adjacent buttons on the keypad:
# `U` moves up, `D` moves down, `L` moves left, and `R` moves right. Each line
# of instructions corresponds to one button, starting at the previous button
# (or, for the first line, **the "5" button**); press whatever button you're on
# at the end of each line. If a move doesn't lead to a button, ignore it.
#
# You can't hold it much longer, so you decide to figure out the code as you
# walk to the bathroom. You picture a keypad like this:
#
# ```
# 1 2 3
# 4 5 6
# 7 8 9
# ```
# Suppose your instructions are:
#
# ```
# ULL
# RRDDD
# LURDL
# UUUUD
# ```
# - You start at "5" and move up (to "2"), left (to "1"), and left (you can't,
#   and stay on "1"), so the first button is `1`.
# - Starting from the previous button ("1"), you move right twice (to "3") and
#   then down three times (stopping at "9" after two moves and ignoring the
#   third), ending up with `9`.
# - Continuing from "9", you move left, up, right, down, and left, ending with
#   `8`.
# - Finally, you move up four times (stopping at "2"), then down once, ending
#   with `5`.
#
# So, in this example, the bathroom code is `1985`.
#
# Your puzzle input is the instructions from the document you found at the front
# desk. What is the **bathroom code**?

# %%
import numpy as np

example = "ULL\nRRDDD\nLURDL\nUUUUD"

input_02 = aoc_open_input("input_02.txt")


def sum_tuples(a: tuple[int, int], b: tuple[int, int]) -> tuple[int, int]:
    return tuple(sum(_) for _ in zip(a, b))


def part_one(input_str: str) -> str:
    """
    Determine the bathroom code based on directional instructions.

    This function processes a series of directional instructions to navigate a
    keypad and generates a code based on the digits corresponding to the final
    positions after following the instructions. The keypad is a 3x3 grid of
    numbers, and the movement is constrained to the grid.


    Parameters
    ----------
    input_str : str
        A string containing directional instructions in the format "U", "D",
        "L", "R", where each character represents a movement direction.

    Returns
    -------
    str
        The bathroom code generated by the sequence of movements on the keypad.
    """

    def pos_check_exists(position: tuple[int, int]) -> bool:
        keypad_range = range(3)
        a, b = position
        return a in keypad_range and b in keypad_range

    key = {"U": (-1, 0), "D": (1, 0), "L": (0, -1), "R": (0, 1)}

    keypad = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

    start_pos = (1, 1)

    code = ""
    pos = start_pos
    for line in input_str.splitlines():
        for char in line:
            proposed_pos = sum_tuples(pos, key[char])
            pos = proposed_pos if pos_check_exists(proposed_pos) else pos
            digit = keypad[pos]
        code += str(digit)

    # print(code)
    return code


# %%
# aoc_answer_display(part_one(example))

# %%
aoc_answer_display(part_one(input_02))

# %% [markdown]
# ## --- Part Two ---
#
# You finally arrive at the bathroom (it's a several minute walk from the lobby
# so visitors can behold the many fancy conference rooms and water coolers on
# this floor) and go to punch in the code. Much to your bladder's dismay, the
# keypad is not at all like you imagined it. Instead, you are confronted with
# the result of hundreds of man-hours of bathroom-keypad-design meetings:
#
# ```
#     1
#   2 3 4
# 5 6 7 8 9
#   A B C
#     D
# ```
#
# You still start at "5" and stop when you're at an edge, but given the same
# instructions as above, the outcome is very different:
#
# - You start at "5" and don't move at all (up and left are both edges), ending
#   at `5`.
# - Continuing from "5", you move right twice and down three times (through "6",
#   "7", "B", "D", "D"), ending at `D`.
# - Then, from "D", you move five more times (through "D", "B", "C", "C", "B"),
#   ending at `B`.
# - Finally, after five more moves, you end at `3`.
#
# So, given the actual keypad layout, the code would be `5DB3`.
#
# Using the same instructions in your puzzle input, what is the correct
# **bathroom code**?


# %%
def part_two(input_str: str) -> str:
    """
    Determine the bathroom code based on directional instructions.

    This function processes a series of directional instructions to navigate a
    keypad and generates a code based on the digits corresponding to the final
    positions after following the instructions. The keypad is a 3x3 grid of
    numbers, and the movement is constrained to the grid.


    Parameters
    ----------
    input_str : str
        A string containing directional instructions in the format "U", "D",
        "L", "R", where each character represents a movement direction.

    Returns
    -------
    str
        The bathroom code generated by the sequence of movements on the keypad.
    """

    directions = {
        "U": np.array([-1, 0]),
        "D": np.array([1, 0]),
        "L": np.array([0, -1]),
        "R": np.array([0, 1]),
    }

    keypad = np.array(
        [
            [np.nan, np.nan, 1, np.nan, np.nan],
            [np.nan, 2, 3, 4, np.nan],
            [5, 6, 7, 8, 9],
            [np.nan, "A", "B", "C", np.nan],
            [np.nan, np.nan, "D", np.nan, np.nan],
        ]
    )

    start_pos = np.argwhere(keypad == "5")[0]

    def pos_check_exists(position: np.ndarray) -> bool:
        return (
            np.sum((np.argwhere(keypad != "nan")[:, None] == position).all(2).any(1))
            == 1
        )

    code = ""
    pos = start_pos
    for line in input_str.splitlines():
        for char in line:
            proposed_pos = pos + directions[char]
            pos = proposed_pos if pos_check_exists(proposed_pos) else pos
            a, b = pos
            digit = keypad[a, b]
        code += str(digit)

    return code


# %%
def part_two_sourcery(input_str: str) -> str:
    """
    Determine the bathroom code based on directional instructions.

    This function processes a series of directional instructions to navigate a
    keypad and generates a code based on the digits corresponding to the final
    positions after following the instructions. The keypad is a 3x3 grid of
    numbers, and the movement is constrained to the grid.

    Parameters
    ----------
    input_str : str
        A string containing directional instructions in the format "U", "D",
        "L", "R", where each character represents a movement direction.

    Returns
    -------
    str
        The bathroom code generated by the sequence of movements on the keypad.
    """

    key = {"U": (-1, 0), "D": (1, 0), "L": (0, -1), "R": (0, 1)}

    keypad = [
        [None, None, 1, None, None],
        [None, 2, 3, 4, None],
        [5, 6, 7, 8, 9],
        [None, "A", "B", "C", None],
        [None, None, "D", None, None],
    ]

    start_pos = (2, 0)

    def pos_check_exists(position: tuple[int, int]) -> bool:
        a, b = position
        return (
            0 <= a < len(keypad)
            and 0 <= b < len(keypad[a])
            and keypad[a][b] is not None
        )

    code = ""
    pos = start_pos
    for line in input_str.splitlines():
        for char in line:
            proposed_pos = (pos[0] + key[char][0], pos[1] + key[char][1])
            # proposed_pos = sum_tuples(pos, key[char])
            if pos_check_exists(proposed_pos):
                pos = proposed_pos
            a, b = pos
            digit = keypad[a][b]
        code += str(digit)

    return code


# %%
# %timeit part_two(input_02)

# %%
# %timeit part_two_sourcery(input_02)

# %%
aoc_answer_display(part_two(input_02))
